---
layout: post
title: Scala
description: "Concepts and lessons that I learned while learning Scala."
modified: 2015-06-13
tags: [Scala, scalable, language]
image:
  feature:
  credit:
  creditlink:
---
Scala stands for "scalable language". It is more of a scripting language. It offers java interoperability which means you can use java libraries and tools. Scala compiles to java bytecode and works with any standard JVM.

* Almost everything in Scala is an expression.
* You can give expressions a name by using `val`.

```
scala> val two = 1 + 1
two: Int = 2
```

You can change binding of the expression to val.
* To change the binding use, `var` instead.
* Functions are defined by `def`. Just like Python you can even have anonymous functions, meaning, you can have functions on the fly and use it, pass it and save them to vals.
* In scala you can use `-` as a magic wildcard anywhere. It means different in different context. For exapmle, here `{ _, 2}` it means an unnamed parameter.
* Carried functions in Scala lets you give a function all the parameters later on. For Example,

```
scala> def multiply(m: Int)(n: Int): Int = m * n
multiply: (m: Int)(n: Int)Int

scala> val timesTwo = multiply(2) _
timesTwo: (Int) => Int = <function1>

scala> timesTwo(3)
res1: Int = 6
```

* You can give variable number of arguments in a function definition.

```
def capitalizeAll(args: String*) = {
  args.map { arg =>
    arg.capitalize
  }
}

scala> capitalizeAll("rarity", "applejack")
res2: Seq[String] = ArrayBuffer(Rarity, Applejack)
```

* Scala is highly expression-oriented: most things are expressions rather than statements.
* `traits` are collections of fields and behaviors that you can extend or mixin with classes. One class can extend several classes using the `with` keyword.
* Pattern Matching is one of the most useful parts in Scala.
Matching on values:

```
val times = 1

times match {
  case 1 => "One"
  case 2 => "Two"
  case _ => "Some other number"
}
```

Matching with guards:

```
times match {
  case i if i == 1 => "One"
  case i if i == 2 => "Two"
  case _ => "Some other number"
}
```

So by 'guards' we mean trapping the value in 'i'. The `_` in the last statement ensures that any other number is caught or else you will run into run time error when you pass some other value.
* `match` can handle different values differently.

```
def bigger(o: Any): Any = {
  o match {
    case i: Int if i < 0 => i - 1
    case i: Int => i + 1
    case d: Double if d < 0.0 => d - 0.1
    case d: Double => d + 0.1
    case text: String => text + "s"
  }
}
```

* Matching can also be done on class members.

```
def calcType(calc: Calculator) = calc match {
  case _ if calc.brand == "hp" && calc.model == "20B" => "financial"
  case _ if calc.brand == "hp" && calc.model == "48G" => "scientific"
  case _ if calc.brand == "hp" && calc.model == "30B" => "business"
  case _ => "unknown"
}
```
